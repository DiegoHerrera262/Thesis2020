This chapter introduces time simulation algorithms for Hamiltonian \ref{eq:HeisenbergHamiltonian}. First a trotterization scheme is introduced, and its advantages are discussed for simulating certain types of graphs or lattices. Relations between discretization step, evolution time and evolution error are computed and discussed in order to establish disadvantages of execution on current (noisy) quantum devices. Then, three possible implementation strategies are introduced: 1) a direct transpilation of circuits proposed by Las Heras et. al. \cite{HubbardSimulLasHeras}, 2) a basis-efficient transpilation relying on commutation properties of local Hamiltonians \footnote{The work was performed at early stages independently of that on \cite{BellUniversalCartan}. However, the insights are identical and thus the author is compelled to refer to this previous work. It is clear, however, that the mentioned reference considers the problem of universal two qubit gates which, albeit related to the specific problem of the present dissertation, is a quite different approach. This dissertation uses the results derived to solve a specific time evolution problem with potential application to specific areas of solid state physics and physical chemistry.}, and 3) a pulse-efficient transpilation based on cross-resonance interaction. Finally, the three algorithms are tested using a three-qubit Hamiltonian. Time evolution of probability density, and of single-qubit Pauli operators' expected values, are computed. Whereas probability density fidelity and state fidelity are used as quantitative indicators.

\section{Trotterization And Time Evolution}
\label{sec:MainTrotterScheme}

  Consider the multiple spin Hamiltonian

  \begin{equation}
    \hat{H} = \sum_{\langle i,j \rangle} J_{ij}^{(X)} \hat{X}_i \hat{X}_j + J_{ij}^{(Y)} \hat{Y}_i \hat{Y}_j + J_{ij}^{(Z)} \hat{Z}_i \hat{Z}_j + \sum_i h_i^{(X)} \hat{X}_i + h_i^{(Y)} \hat{Y}_i + h_i^{(Z)} \hat{Z}_i,
    \label{eq:HeisenbergHamiltonian2}
  \end{equation}

  \noindent defined over an arbitrary graph. The shape already suggests that the Hamiltonian above can be decomposed in local interactions of the shape

  \begin{gather}
    \hat{H}_{ij} = J_{ij}^{(X)} \hat{X}_i \hat{X}_j + J_{ij}^{(Y)} \hat{Y}_i \hat{Y}_j + J_{ij}^{(Z)} \hat{Z}_i \hat{Z}_j, \\
    \hat{H}_{i} = h_i^{(X)} \hat{X}_i + h_i^{(Y)} \hat{Y}_i + h_i^{(Z)} \hat{Z}_i,
    \label{eq:HamiltonianDecomposition}
  \end{gather}

  \noindent such that

  \begin{equation}
    \hat{H} = \sum_{\langle i,j \rangle} \hat{H}_{ij} + \sum_i \hat{H}_i.
  \end{equation}

  This leads to a direct second order trotterization of the shape

  \begin{equation}
    \mathrm{e}^{-\mathrm{i}\hat{H}\Delta t} \approx \prod_{\langle i,j \rangle} \mathrm{e}^{-\mathrm{i}\hat{H}_{i,j}\Delta t} \prod_{i} \mathrm{e}^{-\mathrm{i}\hat{H}_i \Delta t} + \mathcal{O}(\Delta t^2).
    \label{eq:HamiltonianTrotterization}
  \end{equation}

   \noindent Interactions associated to disjoint edges commute, and thus can be simulated simultaneously. Hence, an advantage of this approach to time evolution is that by partitioning the graph on mutually disjoint sets, several terms can be implemented in parallel on actual quantum devices. This approach is implemented in the present work. This parallelism is illustrated for a spin chain in figure \ref{fig:spinChainCircuit}. It can be noticed that the circuit depth of the trotter step of three or more spins with chain topology is independent of the number of spins. As a result, time complexity only increases with the desired time discretization, which correlates with the error in the time simulation approximation. 
  
  Another interesting feature, as shown in figure \ref{fig:spinChainCircuit}, is that it is possible to perform third order time evolution using the first iteration of Suzuki-Trotter scheme with roughly the same time complexity as the second order trotterization. To illustrate this point more precisely, consider the Hamiltonian

  \begin{equation}
    \hat{H} = \sum_{i=0}^{\mathcal{N}-2} \hat{H}_{i,i+1},
    \label{eq:ChainHamiltonian}
  \end{equation}

  \noindent where $\hat{H}_{i,j}$ is defined as on equation \ref{eq:HamiltonianDecomposition}. It is straightforward to see that the second order evolution corresponds to the approximation

  \begin{equation}
    \mathrm{e}^{-\mathrm{i}\hat{H}\Delta t} \approx \prod_{i \text{ even}} \mathrm{e}^{-\mathrm{i}\hat{H}_{i,i+1}t} \prod_{i \text{ odd}} \mathrm{e}^{-\mathrm{i}\hat{H}_{i,i+1}t} + \mathcal{O}(\Delta t^2).
    \label{eq:HamiltonianTrotterization}
  \end{equation}

  \noindent For this particular system, denote

  \begin{gather}
    \hat{A}(\Delta t) = \prod_{i \text{ even}} \mathrm{e}^{-\mathrm{i}\hat{H}_{i,i+1}t}, \\
    \hat{B}(\Delta t) = \prod_{i \text{ odd}} \mathrm{e}^{-\mathrm{i}\hat{H}_{i,i+1}t},
    \label{eq:ChainOpsTrotter}
  \end{gather}

  \noindent such that

  \begin{equation}
    \mathrm{e}^{-\mathrm{i}\hat{H}\Delta t} \approx \hat{A}(\Delta t) \hat{B}(\Delta t) + \mathcal{O}(\Delta t^2).
    \label{eq:HamiltonianTrotterization}
  \end{equation}

  Simulation over a time $t = M \Delta t$ yields

  \begin{equation}
    \mathrm{e}^{-\mathrm{i}\hat{H}t} \approx \bigg( \hat{A}(\Delta t) \hat{B}(\Delta t) \bigg)^{M}.
    \label{eq:HamiltonianTrotterization}
  \end{equation}

  The third order scheme may be implemented using Suzuki-Trotter zeroth order evolution (eq. \ref{eq:Suzuki0}), yielding the following finite time approximation

  \begin{equation}
    \begin{aligned}
      \mathrm{e}^{-\mathrm{i}\hat{H}t} \approx & \bigg( \hat{A}(\Delta t/2) \hat{B}(\Delta t) \hat{A}(\Delta t/2) \bigg)^{M} \\
    = &  \hat{A}(\Delta t/2) \bigg( \hat{B}(\Delta t) \hat{A}(\Delta t) \bigg)^{M-1} \hat{B}(\Delta t) \hat{A}(\Delta t/2) \\
    = & \hat{A}(\Delta t/2) \hat{B}(\Delta t) \bigg( \hat{A}(\Delta t) \hat{B}(\Delta t) \bigg)^{M-1} \hat{A}(\Delta t/2).
    \label{eq:HamiltonianTrotterization}
    \end{aligned}
  \end{equation}

  It can be seen that the \textit{power} operator (the one with a power in the approximation unitary) on each scheme can be implemented in the same fashion on a quantum circuit. Hence, both second order and third order schemes have roughly the same time complexity when implemented on quantum devices. This optimization is taken into account during implementation on IBM Quantum backends.
  
  \include{includes/spinChainCircuit}

  \subsection{Limitations of the Scheme for Time Evolution}
  \label{subsec:TrotterDynamics}

    There are some intrinsic limitations to quantum time simulation using Trotter schemes. To exemplify this, consider an isotropic $\mathcal{N}$-spin chain Hamiltonian, with only two-spin interaction given by

    \begin{equation}
      \hat{H}_{ij} = \frac{1}{2} \hat{X}_i \hat{X}_j + \hat{Y}_i \hat{Y}_j + \frac{1}{4} \hat{Z}_i \hat{Z}_j.
      \label{eq:FloquetHamiltonian}
    \end{equation}

    Consider an initial state $\ket{\psi_0} = \ket{11} \otimes \ket{0}^{\otimes \mathcal{N}-2}$. Evolution over a time $t$ would yield an output (target) state

    \begin{equation}
      \ket{\psi_t} = \mathrm{e}^{-\mathrm{i}\hat{H}t} \ket{\psi_0}
      \label{eq:TargetState}.
    \end{equation}

    On the other hand, this target state may be approximated by the unitary evolution

    \begin{equation}
      \ket{\psi_t(\Delta t)} = \hat{U}(\Delta t)^{\lfloor \frac{t}{\Delta t} \rfloor} \ket{0}.
      \label{eq:ApproxTargetState}
    \end{equation}

    The long time average state fidelity $\mathcal{F}_\infty$ can be defined as follows:

    \begin{equation}
      \mathcal{F}_\infty(\Delta t) = \lim_{M \rightarrow \infty} \frac{1}{M} \sum_{m = 1}^{M} |\braket{\psi_{M\Delta t}}{\psi_{M\Delta t}(\Delta t)}|^2.
    \end{equation}

    In figure \ref{fig:FloquetDynamics}, a plot of long time average state infidelity $1-\mathcal{F}_\infty$ can be seen, for different system sizes ($\mathcal{N} = 2,4,6,8$). It can be seen that there are two clearly separated regimes. For large integration time step $\Delta t$, the average fidelity is almost zero, which means that the evolution does not converge in general. However, below certain threshold $\Delta t_c$, the average fidelity increases deterministically, following a power law. The results suggest that there may be a limit of large systems (i.e., a possible thermodynamic limit). This results have been observed on previous work by \cite{FloquetTrotter}. In that work, it is claimed that the low fidelity regime experience a quantum chaotic dynamics, while the deterministic fidelity regime experiences quantum localization of the system's state. Evidence is provided for the transverse field Ising model. However, due to time constraints, those claims are not demonstrated in this work for the example interaction \ref{eq:FloquetHamiltonian}.

    \begin{figure}
      \centering
      \includegraphics[scale=0.8]{longTimeFloquetFidelity.pdf}
      \caption{Long time state infidelity as a function of integration time step $\Delta t$. Different sets of data are taken for system sizes $\mathcal{N} = 2,4,6,8$. Units are normalized to $\hbar = 1$. This normalization is denoted $(u. a.)$.}
      \label{fig:FloquetDynamics}
    \end{figure}

\section{Circuit implementations}
\label{sec:MainCircuits}
  
  On chapter \ref{chap:qc}, some networks for simulating time evolution of the two-qubit Hamiltonian were introduced (see fig. \ref{fig:salathe-includes}). In this section, three possible transpiled circuits are introduced. Those implement the single qubit and two qubit operators on equation \ref{eq:HamiltonianDecomposition}. The single qubit operators are implemented in the same way on all three alternatives. Each circuit differs from the others on the implementation of the two spin operators. The first alternative is a direct basis transpilation, based on the controlled phase gate. The second alternative is one that takes advantage of the commutation properties of the local two spin Hamiltonian. This alternative was derived mostly independently from \cite{BellUniversalCartan} at early stages of the present work. However, a thorough discussion of the insights required to derive this circuit is included. The last option is a cross resonance based implementation, as discussed on chapter \ref{chap:qc}.

  \subsection{Simulation of field interaction}
  \label{subsec:fieldInteractionCircuit}

    To simulate evolution under Hamiltonian \ref{eq:HamiltonianDecomposition}, a direct approach would be to us te definition of single qubit rotations, and implement a second order trotterization scheme as illustrated on figure \ref{fig:directSimulationFieldSpin}. However, exact simulation of this model is possible by rotating the Bloch sphere main axes so that the external field points to the $\hat{z}$ direction. This can be done by the operator

    \begin{equation}
      \hat{U}_{\theta,\phi} = \begin{bmatrix}
        \cos(\frac{\theta}{2}) & \sin(\frac{\theta}{2}) \\
        \mathrm{e}^{\mathrm{i}\phi}\sin(\frac{\theta}{2}) & -\mathrm{e}^{\mathrm{i}\phi}\cos(\frac{\theta}{2}),
      \end{bmatrix}
      \label{eq:UGate}
    \end{equation}

    \noindent where $\theta$ and $\phi$ are defined by the spherical representation of the external field (see eq. \ref{eq:PolarRepresentation}):

    \begin{gather}
      h^2 =  (h_i^{(x)})^2 + (h_i^{(y)})^2 + (h_i^{(z)})^2 ,\\
      h_i^{(x)} = h \sin(\theta)\cos(\phi), \\
      h_i^{(y)} = h \sin(\theta)\sin(\phi), \\
      h_i^{(z)} = h \cos(\theta).
      \label{eq:PolarRepresentation}
    \end{gather}

    This approach is illustrated on figure \ref{fig:rotatedSimulationFieldSpin}. Therefore, at the same computational cost, this interaction can be simulated exactly by the former algorithm.

    \input{includes/directTrotterizationFieldSpin}

  \subsection{Simulation of Two-spin Interaction}
  \label{subsec:TwoSpinCircuits}

    The simpler spin-spin Hamiltonian

    \begin{equation}
      \hat{H}_{ij} = J_{ij}^{(X)} \hat{X}_i \hat{X}_j + J_{ij}^{(Y)} \hat{Y}_i \hat{Y}_j + J_{ij}^{(Z)} \hat{Z}_i \hat{Z}_j
      \label{eq:SpinSpin}
    \end{equation}

    \noindent is simulated using IBM Quantum device's universal set, or cross resonance pulses. This is the most computationally expensive part of the evolution scheme. As may be seen on figure \ref{fig:echoedPulseQiskit}, the most time consuming processes are simulating two qubit interactions. In consequence, reducing the number and duration of CNOT gates or cross resonance pulses on the evolution algorithm is crucial for obtaining high fidelity results. Here, a first network that performs direct transpilation of circuit \ref{fig:heras-hubbard} is presented. It will be used as a control case, since non-optimized transpilations would yield this network for simulating the Hamiltonian \cite{Qiskit}. A basis efficient circuit is introduced, and its mathematical and physical insights are discussed \cite{BellUniversalCartan}. Finally, the pulse efficient network proposed on \cite{RXZPulseEfficient} is revisited.
    
    \subsubsection{Direct transpilation circuit}
    \label{subsubsec:DirectTranspilationCircuit}

      To adapt circuit \ref{fig:heras-hubbard} for IBM Quantum devices, it is helpful to note that

      \begin{equation}
        \mathrm{e}^{-\mathrm{i}\phi \hat{Z}_i \otimes \hat{Z}_j} = \cos(\frac{\phi}{2}) - \mathrm{i}\sin(\frac{\phi}{2}) \hat{Z}_i \otimes \hat{Z}_j = 
        \begin{bmatrix}
          \mathrm{e}^{-\mathrm{i}\frac{\phi}{2}} & 0 & 0 & 0 \\
          0 & \mathrm{e}^{\mathrm{i}\frac{\phi}{2}} & 0 & 0 \\
          0 & 0 & \mathrm{e}^{\mathrm{i}\frac{\phi}{2}} & 0 \\
          0 & 0 & 0 & \mathrm{e}^{-\mathrm{i}\frac{\phi}{2}}.
        \end{bmatrix}
        \label{eq:expZZ}
      \end{equation}

      By the definition of CNOT gate, and single-qubit gates (see chap. \ref{chap:qc}), it follows that this operator can be implemented by the circuit on figure \ref{fig:directTrotterSpinZZ}. A direct way to simulate the $XX$ interaction term is to note that

      \begin{equation}
        \hat{H}^{\otimes 2} \mathrm{e}^{-\mathrm{i}\phi \hat{Z}_i \otimes \hat{Z}_j} \hat{H}^{\otimes 2} = \mathrm{e}^{-\mathrm{i}\phi \hat{X}_i \otimes \hat{X}_j},
        \label{eq:Z2X}
      \end{equation}

      \noindent where $\hat{H}$ means the Hadamard gate, not the target Hamiltonian. This follows from the observation that $\hat{H}\hat{Z}\hat{H} = \hat{X}$. In a similar fashion, it is possible to implement the $YY$ interaction by noticing that

      \begin{equation}
        \Big(\hat{R}_{\hat{z}, \pi/2}^{\dagger}\hat{H}\Big)\hat{Z}\Big(\hat{R}_{\hat{z}, \pi/2}^{\dagger}\hat{H}\Big)^{\dagger} = \hat{Y}.
        \label{eq:Z2Y}
      \end{equation}

      \input{includes/directTrotterSpinSpin}

      This leads to a straightforward algorithm for simulating spin-spin interaction that uses 6 CNOT gates, and 15 single-qubit rotations. 
    
    \subsubsection{Basis efficient circuit}
    \label{subsubsec:BasisEfficientCircuit}

      This gate count can be reduced further by considering the commutation relations between the operators that constitute the spin-spin interaction Hamiltonian

      \begin{equation}
        [\hat{X}_i\hat{X}_j, \hat{Z}_i\hat{Z}_j] = [\hat{Y}_i\hat{Y}_j, \hat{Z}_i\hat{Z}_j] = 0.
        \label{eq:CommutationRelations}
      \end{equation}

      From basic quantum mechanics, there exists a basis that diagonalizes Hamiltonian \ref{eq:SpinSpin}. By an appropriate rotation, evolution can be performed using mostly $\hat{z}$ axis rotations, and few two-qubit operations. This basis is straightforward to find by noticing that the \textit{total spin} operator

      \begin{equation}
        \hat{S}^2 = 6 + 2\Big(\hat{X}_i\hat{X}_j + \hat{Y}_i\hat{Z}_j + \hat{Z}_j\Big) 
        \label{eq:TotalSpin}
      \end{equation}

      \noindent commutes with the spin-spin interaction Hamiltonian. From elementary quantum physics, it is known that the eigenstates of such operator are the singlet and triplet states \cite{Beck}. By mapping quantum bit value to spin value directly, it can be readily seen that the singlet and triplet states correspond exactly to the \textit{Bell states} defined on equations \ref{eq:BellBasis}. By considering that

      \begin{gather}
        \hat{X}_i\hat{X}_j \ket{\Phi^{\pm}} = \pm\ket{\Phi^{\pm}}, \\
        \hat{Y}_i\hat{Y}_j \ket{\Phi^{\pm}} = \mp\ket{\Phi^{\pm}}, \\
        \hat{Z}_i\hat{Z}_j \ket{\Phi^{\pm}} = \ket{\Phi^{\pm}},
        \label{eq:PhiBellBasisOps}
      \end{gather}

      \begin{gather}
        \hat{X}_i\hat{X}_j \ket{\Psi^{\pm}} = \pm\ket{\Psi^{\pm}}, \\
        \hat{Y}_i\hat{Y}_j \ket{\Psi^{\pm}} = \pm\ket{\Psi^{\pm}}, \\
        \hat{Z}_i\hat{Z}_j \ket{\Psi^{\pm}} = -\ket{\Psi^{\pm}},
        \label{eq:PsiBellBasisOps}
      \end{gather}

      \noindent it is possible to obtain the energies of the Hamiltonian:

      \begin{gather}
        \hat{H}_{ij} \ket{\Psi^{\pm}} = \bigg(-J_{ij}^{(Z)} \pm (J_{ij}^{(X)} + J_{ij}^{(Y)})\bigg) \ket{\Psi^{\pm}}, \\
        \hat{H}_{ij} \ket{\Phi^{\pm}} = \bigg(J_{ij}^{(Z)} \pm (J_{ij}^{(X)} - J_{ij}^{(Y)})\bigg) \ket{\Phi^{\pm}}.
        \label{eq:SpinSpinEnergies}
      \end{gather}

      Define phases

      \begin{gather}
        \phi_{xx} = 2 J_{ij}^{(X)} \Delta t, \\
        \phi_{yy} = -2 J_{ij}^{(Y)} \Delta t, \\
        \phi_{zz} = 2 J_{ij}^{(Z)} \Delta t,
        \label{eq:SpinSpinPhases}
      \end{gather}
      
      \noindent where $\Delta t$ is the time interval to be simulated. A quantum circuit representing this approach to evolution is presented on figure \ref{fig:abelianTrotterSpinSpin}. Main stages are separated by slices, which correspond to:

      \begin{enumerate}
        \item Basis change from computational to Bell.
        \item Append $\phi_{xx}$ and $\phi_{zz}$ phases.
        \item Shuffle the basis to append $\phi_{yy}$ phase.
        \item Return to ordered Bell basis
      \end{enumerate}

      In the first stage, the Bell basis is mapped according to

      \begin{gather}
        \ket{\Phi^{+}} \rightarrow \ket{00}, \\
        \ket{\Phi^{-}} \rightarrow \ket{01}, \\
        \ket{\Psi^{+}} \rightarrow \ket{10}, \\
        \ket{\Psi^{-}} \rightarrow \ket{11}. 
      \end{gather}

      From equations \ref{eq:SpinSpinEnergies}, it may be noted that $xx$ phase correlates to the less significant bit, while $zz$ phase correlates to the most significant bit. Also, $yy$ phase correlates to the parity of the mapped computational basis state, hence the need of a CNOT gate. The last part undoes the CNOT gate action on the previous step, and returns to the Bell basis. The direct way to perform the last step is illustrated on figure \ref{fig:abelianTrotterSpinSpin}(a). A more clever approach relies on the following equalities (up to global state phases)

      \begin{gather}
        \ket{\Phi^{+}} = \frac{1}{\sqrt{2}}(\ket{00} + \ket{11}) = \frac{1}{\sqrt{2}}(\ket{+\mathrm{i},-\mathrm{i}} + \ket{-\mathrm{i},+\mathrm{i}}), \\
        \ket{\Phi^{-}} = \frac{1}{\sqrt{2}}(\ket{00} - \ket{11}) = \frac{1}{\sqrt{2}}(\ket{+\mathrm{i},+\mathrm{i}} + \ket{-\mathrm{i},-\mathrm{i}}), \\
        \ket{\Psi^{+}} = \frac{1}{\sqrt{2}}(\ket{01} + \ket{10}) = \frac{1}{\sqrt{2}}(\ket{+\mathrm{i},+\mathrm{i}} - \ket{-\mathrm{i},-\mathrm{i}}), \\
        \ket{\Psi^{-}} = \frac{1}{\sqrt{2}}(\ket{01} - \ket{10}) = \frac{1}{\sqrt{2}}(\ket{+\mathrm{i},-\mathrm{i}} - \ket{-\mathrm{i},+\mathrm{i}}), 
        \label{eq:bellOnYBasis}
      \end{gather}

      \noindent where the single qubit states $\{\ket{+\mathrm{i}}, \ket{+\mathrm{i}}\}$ are defined as on chapter \ref{chap:qc}, and correspond to the $\hat{Y}$ eigenstates. The shuffling stage that appends $yy$ phase actually permutes states $\ket{\Psi^{-}}$ and $\ket{\Psi^{+}}$ of the Bell basis. It is now easy to see that by performing single qubit rotations that are equivalent to the mappings (where the subindex corresponds to qubits 0 and 1, respectively)

      \begin{gather}
        \ket{0}_0 \rightarrow \ket{-\mathrm{i}}_0, \\
        \ket{1}_0 \rightarrow -\mathrm{i}\ket{+\mathrm{i}}_0, \\
        \ket{0}_1 \rightarrow \ket{+\mathrm{i}}_1, \\
        \ket{1}_1 \rightarrow \mathrm{i}\ket{-\mathrm{i}}_1, \\
        \label{eq:localBellShuffling}
      \end{gather}

       \noindent it is possible to perform the desired reordering without using an additional CNOT gate. Such procedure is illustrated on figure \ref{fig:abelianTrotterSpinSpin}(b). On the last state, the computational basis is mapped back to the Bell basis, and the reordering is performed on the Bell basis using local rotations that correspond to transformation \ref{eq:localBellShuffling}. As a result, the number of expensive CNOT gates has been halved with respect to the direct transpilation circuit.

      \input{includes/abelianTrotterSpinSpin}

    \subsection{Pulse efficient implementation}
    \label{subsubsec:PulseEfficientCircuit}

      On subsection \ref{subsec:EchoedCrossResonance}, a pulse schedule, introduced in \cite{RXZPulseEfficient}, was presented as an efficient alternative for implementing the unitary operators

      \begin{equation}
        \hat{U}(\alpha, \beta, \gamma) = \mathrm{e}^{-\mathrm{i}(\alpha\hat{X}\hat{X} + \beta\hat{Y}\hat{Y} + \gamma\hat{Z}\hat{Z})}
        \label{eq:CartanDecomp2}.
      \end{equation}

      It can be readily seen that the relations

      \begin{gather}
        \alpha = J_{xx} \Delta t, \\
        \beta = J_{yy} \Delta t, \\
        \gamma = J_{zz} \Delta t,
      \end{gather}

      \noindent yield a unitary that exactly performs time evolution under the two-spin interaction Hamiltonian. The single qubit rotations used on the network representation \ref{fig:PulseEffcientCartanCircuit} profit from the relations between Pauli operators stated on equations \ref{eq:Z2X} and \ref{eq:Z2Y}. This algorithm has a slightly different nature than those presented previously. The former two use a particular basis to implement a quantum algorithm that can run on any universal device, regardless of the underlying architecture. The one discussed here, on the other hand, is specifically calibrated for IBM Quantum devices using Qiskit SDK and the pulse scaling technique implemented on \cite{RXZPulseEfficient}.

\section{Comparison and Benchmark: Methodology}
\label{sec:Methodology}

  In general, time simulation of a quantum system has at least two requirements: 1) that the state after evolution resembles within given error bounds the actual target state, and 2) that expected values of interesting observables can be extracted within given error bounds. In the present work, those two requirements are assessed by considering expected value time evolution, probability density (pdf) time evolution, and target probability density fidelity. In this section, the fundamental methods for implementing experiments on quantum devices, measuring observables and computing simulation fidelities are discussed. A benchmark system with Hamiltonian

  \begin{equation}
    \hat{H} = \sum_{i=0}^{1}\Bigg(\hat{X}_i\hat{X}_{i+1} + \hat{Y}_i\hat{Y}_{i+1} + \hat{Z}_i\hat{Z}_{i+1} \Bigg)
    \label{eq:BenchmarkHamiltonian}
  \end{equation}

  \noindent is used for simulation on \textit{ibmq jakarta}. The three proposed schemes discussed on previous sections will be benchmarked by computing the metric mentioned above, for this particular system \footnote{In principle, a larger system could be simulated. However, direct pulse control using the methods proposed on \cite{RXZPulseEfficient} depends on the connectivity if quantum devices. \textit{ibmq jakarta} only supports this type of control on a set of three qubits. Hence the constraints for comparison between the propsed algorithms.}. As a control case, a Qiskit's QASM simulator is used to perform time evolution, since it emulates fault-tolerant quantum computation. This base case will be used for comparing the results obtained by performing the experiment on actual quantum devices and further analysis and discussion.

  \subsection{Measurement of observables}
  \label{subsec:MeasurementMethods}

    Consider the set of of Pauli tensor product operators defined on a space of $N$ qubits. Each of this operators can be mapped to the set of strings whose characters indicate the Pauli operator that acts on the corresponding qubit. For instance,

    \begin{equation}
      \hat{I} \otimes \hat{X} \otimes \hat{X},
    \end{equation}

    \noindent denotes a Pauli string operator that acts on a 3-qubit space, and applies and identity gate on the third qubit, while applying an $X$ gate on the first two. It is a well known fact that the set of Pauli tensor product operators constitute a basis for the space of operators defined on an $N$-qubit system's Hilbert space \cite{Nielsen, Strini}. Hence, any operator in that space has the expansion
    
    \begin{equation}
      \hat{O} = \sum_{P} c_P \hat{P}
    \end{equation}

    \noindent where $P$ is a Pauli tensor product operator. This fact yields a direct approach towards measuring expected value of operators. If the expected value of Pauli tensors can be measured, then linearity yields the expected value of any $N$-qubit operator. Now, by default, experiments performed on IBM's quantum devices produce the expected value of the Pauli tensor $\otimes^{N} \hat{Z}$. As a result, by applying local rotations to the qubits according to equations \ref{eq:Z2X} and \ref{eq:Z2Y}, it is possible to measure any Pauli tensor that also includes $\hat{X}$ and $\hat{Y}$ operators. It might be the case that the measured Pauli tensor only acts on a subspace of the register. This is irrelevant, though, since it is possible to trace out the measured subsystem, thus making any action on the complementary system irrelevant \cite{Nielsen}. Hence, measuring all the qubits of the register at once, on each experiment, and applying local rotations, is a valid methodology for recovering any pdf.

    Measuring the probability density is quite straightforward using Qiskit SDK. As mentioned before, the results of the execution of most quantum algorithms produce a single outcome of measuring the register on the computational basis, which can be mapped to a binary string. Approximate reconstruction of the pdf can be carried out by repeating the experiment several times and building an histogram. This is done by Qiskit methods. Once the pdf is reconstructed, the expected value of the operator $\otimes^{N} \hat{Z}$ can be reconstructed by examining the parity of the outcome string, i.e., by the formula
    
    \begin{equation}
      \expval{\otimes^{N} \hat{Z}} = \sum_{s \in \{0,1\}^{N}\}} p(s) \prod_{i \in s} (-1)^{i},
      \label{eq:expValPauliZ}
    \end{equation}

    \noindent where $p(s)$ denots the probability density of the outcomes, and $(-1)^{i}$ is the parity of the characters in the string. By applying local rotations, it is possible to rotate any state from the eigenbasis of any Pauli tensor operator to the computational basis. As a result, the procedure yields the expected value of any Pauli tensor. Linearity does the rest.

    \subsubsection{Readout Error Correction}
    \label{subsubsec:readoutErrorCorrection}

      It must be noted that actual quantum device experience readout errors after measurement. This readout errors are typically modeled like random bit flip channels \cite{Nielsen, Strini}. Suppose that prior to measurement, a quantum state has an associated pdf $p_i$ of measurement on the computational basis. Due to bit flip noise, the actual measured probability is

      \begin{equation}
        p_i' = M_{ij} p_j,
        \label{eq:MarkovMatrix}
      \end{equation}

      \noindent where $M_{ij}$ is the \textit{transition matrix} of the process. To correct readout errors, the transition matrix is measured by preparing the states of the computational basis and performing several measurements in order to get an approximate noisy pdf. Then, the corrected pdf is obtained by inverting the transition matrix as follows:

      \begin{equation}
        p_i = M_{ij}^{-1} p_j'.
        \label{eq:MarkovMatrix}
      \end{equation}

      This procedure is applied any time a pdf is computed from a series of experiments on actual quantum devices. The predefined Qiskit interfaces for this task is used on the implementations.

    \subsubsection{Measuring probability density fidelity}
    \label{subsubsec:PdfFidelityMeasurement}

      In this work, probability density fidelity is used as a quantitative measure of the precision of the evolution. Consider two states $\ket{\psi}$ and $\ket{\psi'}$, that yield two probability densities of measurement in the computational basis, $p_i$ and $p_i'$, respectively. The probability density fidelity of those two distributions is defined \cite{HubbardSimulLasHeras} by the equation

      \begin{equation}
        F_{p_i, p_i'} = \big(\sum_i \sqrt{p_i p_i'}\big)^2.
        \label{eq:PdfFidelityDefinition}
      \end{equation}

      To assess the precision of a time evolution scheme, a target evolution time is fixed, as well as a fixed number of integration steps. The initial state

      \begin{equation}
        \ket{\psi} = \ket{110}
        \label{eq:initialStateBenchmark}
      \end{equation}

      \noindent is evolved using the evolution scheme (by running experiments on \textit{ibmq jakarta}), thus yielding a pdf ($p_i'$) as described in this subsection. The exact pdf ($p_i$) is computed by exact time evolution using numerical diagonalization of the Hamiltonian. The probability density fidelity, for given time and number of integration steps is computed according to equation \ref{eq:PdfFidelityDefinition}.

  \subsection{Device specifications}
  \label{subsec:ibmq_jakartaSpecs}

    All experiments are run on \textit{ibmq jakarta}, a backend with a processor Falcon r5.1H, at the time of development of this work. This processor has seven physical qubits. It has a connectivity as depicted on figure \ref{fig:JakartaConnectivity}. It supports pulse control as on \cite{RXZPulseEfficient}, only on qubits 1, 3, and 5. Like all IBM Quantum devices, its basis set is $\{\hat{S}_x = \sqrt{\hat{X}}, \hat{X}, \hat{R}_{z,\phi} \}$. Those are logical gates, and most of the time, actual execution requires performing swap operations between some qubits due to limited connectivity.

    \begin{figure}
      \centering
      \includegraphics[scale=0.6]{ibmqJakarta.png}
      \caption{Connectivity of \textit{ibmq jakarta} processor. Taken from the official IBM Quantum site.}
      \label{fig:JakartaConnectivity}
    \end{figure}

    Experiments involving direct transpilation and gate-efficient schemes, are performed using qubits 0, 1, and 2. While experiments involving pulse-efficient schemes are performed on qubits 1, 3, and 5. Quantum devices are calibrated each day, and may vary. However, typical parameter values are reported on table \ref{tab:jakartaParams}.

    \begin{table}[!htbp]
      \begin{center}
        \begin{tabular}{| c | c |}
          \hline 
          $T_1$ & 130 $\mu$s \\
          \hline
          $T_2$ & 34 $\mu$s \\
          \hline
          $\epsilon_{\text{CNOT}}$ & 1\% \\
          \hline
          $\epsilon_{\text{Read}}$ & 2\% \\
          \hline
        \end{tabular}
      \end{center}
      \caption{Typical parameter values for \textit{ibmq jakarta}. The coherence times are discussed on the previous chapter. $\epsilon_O$ denotes the error on performing an operation $O$. In this case, CNOT gates and readout.}
      \label{tab:jakartaParams}
    \end{table}
  
    \begin{table}[!htbp]
      \begin{center}
        \begin{tabular}{| c | c |}
          \hline 
          $0 \rightarrow 1$ & 234.7 ns \\
          \hline
          $1 \rightarrow 2$ & 288.4 ns \\
          \hline
          $1 \rightarrow 3$ & 384.0 ns \\
          \hline
          $3 \rightarrow 5$ & 341.3 ns \\
          \hline
          $4 \rightarrow 5$ & 405.3 ns \\
          \hline
          $5 \rightarrow 6$ & 312.9 ns \\
          \hline
        \end{tabular}
      \end{center}
      \caption{Execution times of CNOT gates on \textit{ibmq jakarta}. The column on the left denotes control-target pairs, and the right, the execution time in nanoseconds. Times were acquired using Qiskit API, and is reported from the backend calibration data.}
      \label{tab:jakartaCnotTimes}
    \end{table}

  \subsection{Control case: QASM Simulation Results}
  \label{subsec:QASMResults}

    To establish a control case for evaluating results of quantum evolution on real devices, the benchmark system is simulated over a time $t = 1$ using an integration step $dt = 1/8$. In a more quantitative test, the probability density fidelity is computed for times $t = 1, 2, 3$, with up to $8$ integration steps. Units of time are normalized to $\hbar = 1$, so that energy has units of inverse time. These results represent the outcome of executing the direct evolution scheme introduced on section \ref{sec:MainCircuits}, on a fault tolerant device. In figures \ref{fig:QASMpdf} and \ref{fig:QASMpaulis}, the results of evolution with direct diagonalization of the Hamiltonian are presented as dotted lines.

    Probability density of measuring a 3-bit string is evolved over time. The convention is that the string is represented by its associated number in decimal system. Expected values of single qubit Pauli operators $\hat{X}_i, \hat{Y}_i, \hat{Z}_i$ are measured for each of the qubits. The first qubit observables correspond to color red data, the second qubit's, to blue data, and the third qubit's, to black data. This convention holds on all graphics of this type. Probability density fidelity is computed for several number of integration steps $N$ (up to eight), and each point correspond to the average of five sets of 2048 experimental repetitions.

    A small number of integration steps is used since the finite coherence times of the qubits in the device limit the depth of the circuit that can be executed on real devices. If the gate execution times approach the coherence times, the state coherence is irreversibly lost, and thus the final state does not resemble at all the target final state. As may be seen on figure \ref{fig:QASMfidelity}, there is a sort of transient stage during which the Trotter approximation does not converge. As seen before, there exists a critical integration time step $\Delta t$, below which the state fidelity has a predictable approximation error. It may be also noted that high fidelities can be achieved by using a relatively small number of integration steps. Furthermore, observables resemble quite well the theoretical values. This indicates that as long as the integration time step $\Delta t = t / N$ is below the convergence threshold, the trotter error can be controlled.

    \begin{figure}
      \thisfloatpagestyle{empty}
      \centering
      \begin{subfigure}[b]{1.0\textwidth}
        \centering
        \includegraphics[scale=0.65]{QASMData/qasm_control_pdf_evol.pdf}
        \caption{Time evolution of probability density (pdf) of the benchmark system initialized on the state $\ket{\psi_0} = \ket{110}$, for a time $t=1$. The numbers in the convention are those whose binary representation corresponds to $\ket{k}$.}
        \label{fig:QASMpdf}
      \end{subfigure}
      \hfill
      \begin{subfigure}[b]{1.0\textwidth}
        \centering
        \includegraphics[scale=0.65, trim={0 1.8cm 0 1.8cm}, clip]{QASMData/qasm_control_pauli_exps.pdf}
        \caption{Time evolution of single qubit Pauli operators of the benchmark system initialized on the state $\ket{110}$, for a time $t=1$. The first qubit observables correspond to color red data, the second qubit's, to blue data, and the third qubit's, to black data}
        \label{fig:QASMpaulis}
      \end{subfigure}
      \begin{subfigure}[b]{1.0\textwidth}
        \centering
        \includegraphics[scale=0.65]{QASMData/qasm_control_pdf_fidelity.pdf}
        \caption{Probability density fidelity as a function of the number of integration steps, $N$, and simulation times $t = 1, 2, 3$. Each point corresponds to the average of five sets of experiments. Notice that the transient behavior mentioned lasts up to about $N = 4$.}
        \label{fig:QASMfidelity}
      \end{subfigure}
      \caption{QASM Simulation results. Time units are normalized to $\hbar=1$ and $J_{ij}^{(X)} = J_{ij}^{(Y)} = J_{ij}^{(Z)} = 1$}. This is denoted by (u. a.).
      \label{fig:QASMResults}
    \end{figure}

\section{Comparison and Benchmark: Results}
\label{sec:Results}

    Now that the main metrics, and the way they are measured using \textit{ibmq jakarta}, results of simulation using the schemes proposed on section \ref{sec:MainCircuits} are presented. Results are compared to fault-tolerant simulation outcome in figure \ref{fig:QASMResults}.

    Expected values of single qubit observables are measured following conventions established on section \ref{subsec:QASMResults}. From figure \ref{fig:PauliExpectedValues}, it can be seen that the scheme that produces the largest resemblance to the ideal values (dotted lines) is the pulse efficient implementation, followed by the basis efficient and the direct transpilation. Qualitatively, the difference in performance is overwhelming. While the base efficient and direct transpilation approaches struggle to converge for four steps, the pulse efficient scheme is able to converge surprisingly well for the entire set of eight steps. Since the calibration of entangling gates is the same for all cases (except for a parameter scaling on pulse efficient experiments) it can be inferred that the use of shorter entangling pulses, which improves the usage of the finite coherence times of the system, is the most determinant factor when simulating this kind of Hamiltonians.

    Those features can be seen more clearly on figure \ref{fig:PdfExpectedValues}. From the ideal results on figure \ref{fig:QASMResults}, it can be seen that the probability density only presents oscillations for states $\ket{3}$, $\ket{6}$, and $\ket{5}$. Figures \ref{fig:PdfDirectTransp} and \ref{fig:PdfBasis} suggest that the state coherence is lost very fast (qubits depolarize fairly quickly), and the probability density fidelity decays very rapidly as the circuit depth of simulation increases, using both direct and basis efficient schemes. On the other hand, pulse efficient schemes seem to better maintain state coherence since the execution time of each trotter step is shorter. As a result, the state fidelity is larger.

    On figure \ref{fig:PdfExpectedFidelity}, these observations are made more quantitative. After the transient stage in which the Trotter approximation does not converge in general, it can be seen that the probability density fidelity decays consistently for direct transpilation and basis efficient schemes, as the number of integration steps increase. On the other hand, pulse efficient schemes have an increasing fidelity with the number of integration steps. While the first two schemes produce fidelities near 30\% - 40\%, direct pulse control yields fidelities near 70\% in some cases, having actual execution times about 40\% shorter. There is a caveat, though. As the integration time step increases, the benefits of pulse schemes is reduced, since the actual execution time increases proportionally (see figure \ref{fig:PulseDurationVdt}). This can be seen on figure \ref{fig:PdfPulseFidelity}. As the target simulation time increases, the fidelity remains below 50\%. Since the circuit depth does not change with respect to shorter times, it can be concluded that this reduction in the fidelity is due to the larger execution time of the experiments (see figure \ref{fig:PulseDurationVdt}). In consequence, simulating anisotropic Heisenberg Hamiltonians on quantum computers imply optimizing the tradeoff between short Trotter steps with pulse control, and a large number of repetitions required to simulate large times. As may be inferred from figure \ref{fig:FloquetDynamics}, it must be procured that the integration time step $\Delta t$ is below the threshold for predictable Trotter error control, though.

    \begin{figure}
      \centering
      \includegraphics[scale=0.72]{schedTimeDurationPlot.pdf}
      \caption{Execution time (in relative units) of pulse efficient and basis efficient Trotter steps on IBM Quantum devices as a function of integration time step $\Delta t$.}
      \label{fig:PulseDurationVdt}
    \end{figure}

    \begin{figure}
      \centering
      \begin{subfigure}[b]{1.0 \textwidth}
        \centering
        \includegraphics[scale=0.8, trim={0 1.8cm 0 1.8cm}, clip]{DirectTranspilationData/direct_pauli_exps.pdf}
        \caption{Direct transpilation expected values}
        \label{fig:PauliDirectTransp}
      \end{subfigure}
      \begin{subfigure}[b]{1.0 \textwidth}
        \centering
        \includegraphics[scale=0.8, trim={0 1.8cm 0 1.8cm}, clip]{BasisEfficientData/basis_efficient_pauli_exps.pdf}
        \caption{Basis efficient expected values}
        \label{fig:PauliBasis}
      \end{subfigure}
      \begin{subfigure}[b]{1.0 \textwidth}
        \centering
        \includegraphics[scale=0.8, trim={0 1.8cm 0 1.8cm}, clip]{PulseEfficientData/pulse_efficient_pauli_exps.pdf}
        \caption{Basis efficient expected values}
        \label{fig:PauliPulse}
      \end{subfigure}
      \caption{Time evolution of single qubit expected values on \textit{ibmq jakarta}. Time units are normalized to $\hbar = 1$. This is denoted bu (u. a.) in the figures.}
      \label{fig:PauliExpectedValues}
    \end{figure}

    \begin{figure}
      \centering
      \begin{subfigure}[b]{0.5 \textwidth}
        \centering
        \includegraphics[scale=0.8, trim={2cm 0 2cm 0}, clip]{DirectTranspilationData/direct_pdf_evol.pdf}
        \caption{Direct transpilation pdf.}
        \label{fig:PdfDirectTransp}
      \end{subfigure}%
      \hfill
      \begin{subfigure}[b]{0.5 \textwidth}
        \centering
        \includegraphics[scale=0.8, trim={2cm 0 2cm 0}, clip]{BasisEfficientData/basis_efficient_pdf_evol.pdf}
        \caption{Basis efficient pdf.}
        \label{fig:PdfBasis}
      \end{subfigure}
      \begin{subfigure}[b]{1.0 \textwidth}
        \centering
        \includegraphics[scale=0.8, trim={1cm 0 1cm 0}, clip]{PulseEfficientData/pulse_efficient_pdf_evol.pdf}
        \caption{Basis efficient pdf.}
        \label{fig:PdfPulse}
      \end{subfigure}
      \caption{Time evolution of benchmark system probability density on \textit{ibmq jakarta}.}
      \label{fig:PdfExpectedValues}
    \end{figure}

    \begin{figure}
      \centering
      \begin{subfigure}[b]{1.0 \textwidth}
        \centering
        \includegraphics[scale=0.6]{DirectTranspilationData/direct_pdf_fidelity.pdf}
        \caption{Direct transpilation pdf fidelity.}
        \label{fig:PdfDirectTranspFidelity}
      \end{subfigure}
      \begin{subfigure}[b]{1.0 \textwidth}
        \centering
        \includegraphics[scale=0.6]{BasisEfficientData/basis_efficient_pdf_fidelity.pdf}
        \caption{Basis efficient pdf fidelity.}
        \label{fig:PdfBasisFidelity}
      \end{subfigure}
      \begin{subfigure}[b]{1.0 \textwidth}
        \centering
        \includegraphics[scale=0.6]{PulseEfficientData/pulse_efficient_pdf_fidelity.pdf}
        \caption{Basis efficient pdf fidelity.}
        \label{fig:PdfPulseFidelity}
      \end{subfigure}
      \caption{Fidelity of benchmark system probability density, w. r. t. ideal state fidelity, when simulated on \textit{ibmq jakarta}.}
      \label{fig:PdfExpectedFidelity}
    \end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%